# encoding: utf-8
require 'htmlentities'

module Typograph
  class Processor

    DEFAULTS = {
      :convert_e => false,
      :html_entities => false
    }

    SYM = {
      'nbsp'    => '&nbsp;',
      'lnowrap' => '<span style="white-space:nowrap">',
      'rnowrap' => '</span>',

      'lquote'  => '«',
      'rquote'  => '»',
      'lquote2' => '„',
      'rquote2' => '“',
      'mdash'   => '—',
      'ndash'   => '–',
      'minus'   => '–', # соотв. по ширине символу +, есть во всех шрифтах

      'hellip'  => '…',
      'copy'    => '©',
      'trade'   => '<sup>™</sup>',
      'apos'    => '&#39;',   # см. http://fishbowl.pastiche.org/2003/07/01/the_curse_of_apos
      'reg'     => '<sup><small>®</small></sup>',
      'multiply' => '&times;',
      '1/2' => '&frac12;',
      '1/4' => '&frac14;',
      '3/4' => '&frac34;',
      'plusmn' => '&plusmn;',
      'rarr' => '&rarr;',
      'larr' => '&larr;',
      'rsquo' => '&rsquo;'
    }

    SAFE_BLOCKS = [
      ['<pre[^>]*>','</pre>'],
      ['<style[^>]*>','</style>'],
      ['<script[^>]*>','</script>'],
      ['<!--','-->'],
      ['<code[^>]*>','</code>']
    ]

    # Добавляет безопасный блок, который не будет обрабатываться типографом.
    def add_safe_block(open_tag, close_tag)
      @safe_blocks[open_tag] = close_tag
    end
    
    # Убирает все безопасные блоки типографа.
    # Полезно, если необходимо задать полностью свой набор.
    def remove_all_safe_blocks
      @safe_blocks = {}
    end
    
    # Устанавливает соответствие между символом и его представлением.
    def set_sym(sym, entity)
      SYM[sym] = entity
    end

    def safe_blocks
      pattern ||= begin
        pattern = SAFE_BLOCKS.map do |val|
          val.join('*')
        end.join('|')
        Regexp.new("(#{pattern}|<[^>]*[\\s][^>]*>)", 'isU')
      end
    end
    # Вызывает типограф, обходя html-блоки и безопасные блоки
    def process(str)
      str = HTMLEntities.new.decode(str)
      
      safe_blocks.match str do |match|
        _stack match
      end

      str = typo_text(str)

      if @safe_blocks
        str.gsub!(/<\d>/, _stack)
      end

      str
    end

    # Накапливает исходный код безопасных блоков при использовании в качестве
    # обратного вызова. При отдельном использовании возвращает накопленный
    # массив.
    def _stack(matches = false)
      @safe_blocks = {}
      if matches != false
        key = "<#{@safe_blocks.length}>"
        @safe_blocks[key] = matches[0]
        key
      else
        tmp = @safe_blocks.dup
        @safe_blocks = nil
        tmp
      end
    end
  
    # Применяет все переданные правила к тексту
    def apply_rules(rules, str)
      res = str.dup
      rules.each { |s, r| res.gsub! s, r }
      res
    end

    # Главная функция типографа.
    def typo_text(str)
      sym = SYM

      return '' if str.gsub(/^\s|\s$/, '').empty?

      html_tag = '(?:(?U)<.*>)';
      hellip = '\.{3,5}';
      
      # Слово
      word = '[a-zA-Zа-яА-Я_]';
      
      # Начало слова
      phrase_begin = "(?:#{hellip}|#{word}|\n)";
      
      # Конец слова
      phrase_end   = '(?:[)!?.:;#*\\\]|$|'+word+'|'+sym['rquote']+'|'+sym['rquote2']+'|&quot;|"|'+sym['hellip']+'|'+sym['copy']+'|'+sym['trade']+'|'+sym['apos']+'|'+sym['reg']+'|\')';
      
      # Знаки препинания (троеточие и точка - отдельный случай!)
      punctuation = '[?!:,;]';
      
      # Аббревиатуры
      abbr = 'ООО|ОАО|ЗАО|ЧП|ИП|НПФ|НИИ';
      
      # Предлоги и союзы
      prepos = 'а|в|во|вне|и|или|к|о|с|у|о|со|об|обо|от|ото|то|на|не|ни|но|из|изо|за|уж|на|по|под|подо|пред|предо|про|над|надо|как|без|безо|что|да|для|до|там|ещё|их|или|ко|меж|между|перед|передо|около|через|сквозь|для|при|я';

      # Сокращения  
      metrics = 'мм|см|м|км|г|кг|б|кб|мб|гб|dpi|px';   
      shortages = 'г|гр|тов|пос|c|ул|д|пер|м|зам|см';
      money = 'руб\.|долл\.|евро|у\.е\.';
      counts = 'млн\.|тыс\.';
      
      # Различные виды кавычек
      any_quote = "(?:#{sym['lquote']}|#{sym['rquote']}|#{sym['lquote2']}|#{sym['rquote2']}|&quot;|\")";

      # Правила
      rules_strict = {
        # Много пробелов или табуляций -> один пробел.
        /( |\t|&nbsp;)+/ => ' ',

        # Убираем лишние пробелы между символами 
        # /([!?:;,.]) (?=\1)/ => '\1',

        # /Окружаем символьные массивы пробелами
        # /([.,:;!?]+)/ => ' \1 ', 

        # Убираем все до трех знаков
        / +([!?]!!)!*  ?/ => '\1 ',          # !!! или ?!! + ставим пробел после знаков
        / +(\?\?\?)\?*  ?/ => '\1 ',         # ??? + ставим пробел после знаков
        / +([!?]\.\.)\.*  ?/ => '\1 ',       # !.. + ставим пробел после знаков
        / (\.\.\.)\.* /  => sym['hellip'],   # ... (троеточие) + оставляем пробелы как есть
       
        / +(\?\?)  ?/ => '? ',               # Два ?? в ? + ставим пробел после
        / +[^!?]?(\.\.)  ?/ => '. ',         # Две .. в . + пробел после
        
        # , : ; больше одной быть не может, хотя может foo::getId();
        / +([:;,])+ ?/ => '\1 ',
        
        # Расставзяем пробелы у одиночных знаков припенания
        / +([.,:;!?]) ?/ => '\1 ',
        
        # Занятная комбинация
        / +!\?  ?/ => '?! ',

        # ЗАСАДА! Если было |"текст!" текст| то станет |"текст! " текст|, а это проблема...
        # ?, а не * т.к. уже всё слили... ну да, тогда пробела уже точно нет, так что не нужен?
        # '~(\w)!!([^!])~' => '$1!$2',
        # '~(\w)\?\?([^?])~' => '$1?$2',
        # '~(\w)\.\.([^.])~' => '$1.$2',
        # '~([^\2])([.!?])\2([^\2])~' => '$1$2$3', 
        # '~(?<!\?)(?<!!)(!!)(?!!)~' => '!',     #  Замена 
        # '~(?<!\?)(\?\?)(?!\?)~' => '!',
        # '~(?<!!)(?<!\.)(\.\.)(?!\.)~' => '!',
        # '~ [^!]?(\.\.) ~' => ' . ', 
        # '~ (\?\?) ~' => ' . ',
        
        
        # Убираем повторяющиеся знаки припенания, заменяем троеточие на троеточие (. , : ; ! ? ...)
        # TODO: может тут же убирать пробелы до и ставить один после?
        # '~([!?]!!)!+1?~' => '$1',              #  !!! или ?!! (так же !!!!!!!1 = !!!)
        # '~(\?\?\?)\?+7?~' => '$1',             #  ??? (так же ??????7 = ???)
        # '~(!\.\.)\.+~' => '$1',                #  !..
        # '~(\.\.\.)\.*~' => $sym['hellip'],     #  ...
        
        # Двоеточий, точек с запятой и запятых больше одной быть не должно    
        # '~(\w)([,:;])(?: ?\2)+(\s|\z)~' => '$1$2$3',
        # '~(\w)([,:;])\2+(\s|\z)~' => '$1$2$3',
             
        # Редактурием пробелы в скобках (одновременно удаляя лишние знаки в начале и в конце)
        
        # Исключения типа «программирование .net»
        # Программирование. NET => Программирование .NET  
        # Слово;) => Слово ;)     Слово:) => Слово ;)     Слово:-) => Слово ;-)
        # !!!!!!!!!1 => !!!      ??????????7 => ??? 
        # ...думаю это исключения, которые поправятся после осноггвных правил
        
        # Можно сократить множество скобок до трех...
        
        
        # ------------ более менее чистый код ------------
        
        # Обрабатывам знаки дефисов
        
        # Здесь всякие разные правила, типа: стрелочки, "из-за", символы, дроби, даты и т.д...      

        #  Запятые после «а» и «но». Если уже есть — не ставим.
        # '~([^,])\s(а|но)\s~' => '$1, $2 ',

        #  Оторвать тире от слова (корректно работает с «газо- и электросварка»).
        # '~([a-zа-я])- (?!(,|и|или|либо) )~i' => '$1 - ',
        
        #  Удаление от 4 до 7 повторяющихся слов (думаем что правильно писать через дефис или запятую).
        # '~((\w{2,}) ){4,7}\1~i' => '$1',

        #  Расстановка дефисов перед «-либо», «-нибудь».
        # '~(кто|что|где|когда|почему|зачем|кем|чем) ?(либо|нибудь)~i' => $sym['lnowrap'].'$1'.$sym['ndash'].'$2'.$sym['rnowrap'],

        #  Расстановка дефисов в предлогах «из-за», «из-под», «по-над», «по-под». 
        # '~(из) ?(за|под) ~i' => $sym['lnowrap'].'$1'.$sym['ndash'].'$2'.$sym['rnowrap'].' ',
        # '~(по) ?(над|под) ~i' => $sym['lnowrap'].'$1'.$sym['ndash'].'$2'.$sym['rnowrap'].' ',

        #  Знаки с предшествующим пробелом… нехорошо!
        # '~('.$phrase_end.') +('.$punctuation.'|'.$sym['hellip'].')~' => '$1$2',
        # '~('.$punctuation.')('.$phrase_begin.')~' => '$1 $2',
      
        #  Для точки отдельно
        # '~(\w)\s(?:\.)(\s|$)~' => '$1.$2',

        #  Неразрывные названия организаций и абревиатуры форм собственности
        #  ~ почему не один &nbsp;?
        #  ! названия организаций тоже могут содержать пробел !
        # '~('.$abbr.')\s+(«.*»)~' => $sym['lnowrap'].'$1 $2'.$sym['rnowrap'],

        #  Нельзя отрывать сокращение от относящегося к нему слова.
        #  Например: тов. Сталин, г. Воронеж
        #  Ставит пробел, если его нет.
        # '~(^|[^a-zA-Zа-яА-Я])('.$shortages.')\.\s?([А-Я0-9]+)~s' => '$1$2.'.$sym['nbsp'].'$3',

        #  Не отделять стр., с. и т.д. от номера.
        # '~(стр|с|табл|рис|илл|гл)\.\s*(\d+)~si' => '$1.'.$sym['nbsp'].'$2',

        #  Не разделять 2007 г., ставить пробел, если его нет. Ставит точку, если её нет.
        # '~([0-9]+)\s*([гГ])\.\s~s' => '$1'.$sym['nbsp'].'$2. ',
        
        #  Неразрывный пробел между цифрой и единицей измерения
        # '~([0-9]+)\s*('.$metrics.')~s' => '$1'.$sym['nbsp'].'$2',
        
        #  Сантиметр и другие ед. измерения в квадрате, кубе и т.д.
        # '~(\s'.$metrics.')(\d+)~' => '$1<sup>$2</sup>',  

        #  Знак дефиса или два знака дефиса подряд — на знак длинного тире.
        #  + Нельзя разрывать строку перед тире, например: Знание — сила, Курить — здоровью вредить.
        # '~ +(?:--?|—|&mdash;)(?=\s)~' => $sym['nbsp'].$sym['mdash'],
        # '~^(?:--?|—|&mdash;)(?=\s)~' => $sym['mdash'],
      
        #  Прямая речь
        # '~(?:^|\s+)(?:--?|—|&mdash;)(?=\s)~' => "\n".$sym['nbsp'].$sym['mdash'],

        #  Знак дефиса, ограниченный с обоих сторон цифрами — на знак короткого тире.
        # '~(?<=\d)-(?=\d)~' => $sym['ndash'],

        # Нельзя оставлять в конце строки предлоги и союзы
        # '(?<=\s|^|\W)('+prepos+')(\s+)'
        Regexp.new('(\s|^|\W)('+prepos+')(\s+)', true) => '\1\2'+sym['nbsp'],

        #  Нельзя отрывать частицы бы, ли, же от предшествующего слова, например: как бы, вряд ли, так же.
        # "~(?<=\\S)(\\s+)(ж|бы|б|же|ли|ль|либо|или)(?=$html_tag*[\\s)!?.])~i" => $sym['nbsp'].'$2',

        #  Неразрывный пробел после инициалов.
        # '~([А-ЯA-Z]\.)\s?([А-ЯA-Z]\.)\s?([А-Яа-яA-Za-z]+)~s' => '$1$2'.$sym['nbsp'].'$3',

        #  Сокращения сумм не отделяются от чисел.      
        # '~(\d+)\s?('.$counts.')~s'  =>  '$1'.$sym['nbsp'].'$2',
      
        #  «уе» в денежных суммах
        # '~(\d+|'.$counts.')\s?уе~s'  =>  '$1'.$sym['nbsp'].'у.е.',
          
        #  Денежные суммы, расставляя пробелы в нужных местах.
        # '~(\d+|'.$counts.')\s?('.$money.')~s'  =>  '$1'.$sym['nbsp'].'$2',

        #  Неразрывные пробелы в кавычках
        # "/($sym[lquote]\S*)(\s+)(\S*$sym[rquote])/U" => '$1'.$sym["nbsp"].'$3',
        
        #  Телефоны
        # '~(?:тел\.?/?факс:?\s?\((\d+)\))~i' => 'тел./факс:'.$sym['nbsp'].'($1)',
        # '~тел[:.] ?(\d+)~ie' => "'<span style=\"white-space:nowrap\">тел: '.self::_phone('$1').'</span>'",
        
        #  Номер версии программы пишем неразрывно с буковкой v.
        # '~([vв]\.) ?([0-9])~i' => '$1'.$sym['nbsp'].'$2',
        # '~(\w) ([vв]\.)~i' => '$1'.$sym['nbsp'].'$2',
      
        #  % не отделяется от числа
        # '~([0-9]+)\s+%~' => '$1%',
      
        #  IP-адреса рвать нехорошо
        # '~(1\d{0,2}|2(\d|[0-5]\d)?)\.(0|1\d{0,2}|2(\d|[0-5]\d)?)\.(0|1\d{0,2}|2(\d|[0-5]\d)?)\.(0|1\d{0,2}|2(\d|[0-5]\d)?)~' =>
        # $sym['lnowrap'].'$0'.$sym['rnowrap'],
        
        #  Неразрывный пробел перед последним словом в тексте
        # '~(\s)(\S*)\Z~' => $sym['nbsp'].'$2'
        
        #  Делаем неразрывными слова с дефисом. 
        #  Пример: "слово-слово", "слово-слово-слово".
        # '~(\w+((-|'.$sym['ndash'].')\w+){1,2})~' => $sym['lnowrap'].'$0'.$sym['rnowrap']
          
        # Знаки (c), (r), (tm)
        # /\((c|с)\)/i => sym['copy'],
        # /\(r\)/i     => sym['reg'],
        # /\(tm\)/i    => sym['trade'],
        
        # От 2 до 5 знака точки подряд - на знак многоточия (больше - мб авторской задумкой).
        # Лишнее правило!!! Сверху больше трех в три... так что пяти не будет!
        # Sam: судя по тому, как меняются результаты тестов — не лишнее…
        # Regexp.new(hellip) => sym['hellip'],

        # Спецсимволы для 1/2, 1/4, 3/4
        # /\b1/2\b/ => sym['1/2'],
        # /\b1/4\b/ => sym['1/4'],
        # /\b3/4\b/ => sym['3/4'],

        # Апострофы
        # /([a-zA-Zа-яА-Я])'+([a-zA-Zа-яА-Я])/i => '\1'+sym['rsquo']+'\2',
        # /'/ => $sym['apos'],

        # Размеры 10x10, правильный знак + убираем лишние пробелы
        # /(\d+)\s{0,}?[x|X|х|Х|*]\s{0,}(\d+)/ => '\1'+sym['multiply']+'\2',

        # +-
        # /([^\+]|^)\+-/ => '\1'+sym['plusmn'],
          
        # Стрелки
        # /([^-]|^)->/ => '\1'+sym['rarr'],
        # /<-([^-]|$)/ => sym['larr'] + '\1',

        # Оторвать скобку от слова
        # /(\w)\(/ => '\1 (',
        
        # Слепляем скобки со словами
        # /\( / => '(',
        # / \)/ => ')',
        
        #  Рассавляем кавычки. Можно делать рекурсивно читая "(" началом рекурсии ")" - концом...
   
        #  Здесь добавляем <nobr> </nobr> в словах с дефисами.

        #  Добавляем неразрывный пробел перед последним словом.
      }

      quotes = ['&#34;', '&#171;', '&#187;', '&#8220;', '&#8221;', '&#8222;', 
        '&quot;', '&laquo;', '&raquo;', '&ldquo;', '&rdquo;', '&bdquo;', 
        '«', '»', '„', '“', '„']

      str.gsub!(Regexp.new(quotes.join('|')), '"')

      rules_quotes = {
        #  Разносим неправильные кавычки
        /([^"]\w+)"(\w+)"/ => '\1 "\2"',
        /"(\w+)"(\w+)/ => '"\1" \2',

        #  Превращаем кавычки в ёлочки. Двойные кавычки склеиваем.
        # Regexp.new('(?<=\\s|^|[>(])('+html_tag+'*)('+any_quote+')('+html_tag+'*'+phrase_begin+html_tag+'*)') => '\1'+sym['lquote']+'\3',
        # Regexp.new('('+html_tag+'*(?:'+phrase_end+'|[0-9]+)'+html_tag+'*)('+any_quote+')('+html_tag+'*'+phrase_end+html_tag+'*|\\s|[,<-])') => '\1'+sym['rquote']+'\3'

        /(\s|^|-)"([а-яa-z])/i => '\1'+sym['lquote']+'\2',
        /([а-яa-z!])"(\s|$|,|\.)/i => '\1'+sym['rquote']+'\2'
      }

      str = apply_rules(rules_quotes, str)
          
      # Вложенные кавычки.
      # $i=0; $lev = 5;
      # while (($i<$lev) && preg_match('~«(?:[^»]*?)«~', $str)){
      #   $i++;
      #   $str = preg_replace('~«([^»]*?)«(.*?)»~s', '«$1'.$sym['lquote2'].'$2'.$sym['rquote2'], $str);
      # }

      # $i=0;
      # while (($i++<$lev) && preg_match('~»(?:[^«]*?)»~', $str)){
      #   $i++;
      #   $str = preg_replace('~»([^«]*?)»~', $sym['rquote2'].'$1»', $str);
      # }

      str = apply_rules(rules_strict, str)
      
      if @options[:convert_e]
        str.gsub!('Ё', 'Е').gsub!('ё', 'е')
      end
      
      if @options[:html_entities]
        str = HTMLEntities.new.encode(str)
      end
      
      str.gsub(/^\s+|\s+$/, '')
    end

    def initialize(options = {})
      @options = DEFAULTS.merge(options)
    end
  end
end

# class Typographus{
#   /**
#    * Форматирует число как телефон 89109179966 => 8 (910) 917-99-66
#    * //TODO: доработать либо выкинуть…
#    * @param String $phone
#    * @return String
#    */
#   /*
#   private static function _phone($phone){
#     $result = $phone[0].' ('.$phone[1].$phone[2].$phone[3].') ';
#     $count = 0;
#     $buff='';
#     for ($i=strlen($phone)-1; $i>3; $i--){
#       $left = $i-3;
#       if ($left!=3){
#         if ($count<1){
#           $buff.=$phone[$i];
#           $count++;
#         }
#         else{
#           $buff.=$phone[$i].'-';
#           $count=0;
#         }
#       }
#       else{
#         $buff.=strrev(substr($phone, $i-2, 3));
#       break;
#       }
#     }
  
#     $result.=strrev($buff);
#     return $result;
#   }
#   */
# }
